{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MediaType = void 0;\nObject.defineProperty(exports, \"PermissionStatus\", {\n  enumerable: true,\n  get: function get() {\n    return _expoModulesCore.PermissionStatus;\n  }\n});\nexports.SortBy = void 0;\nexports.addAssetsToAlbumAsync = addAssetsToAlbumAsync;\nexports.addListener = addListener;\nexports.albumNeedsMigrationAsync = albumNeedsMigrationAsync;\nexports.createAlbumAsync = createAlbumAsync;\nexports.createAssetAsync = createAssetAsync;\nexports.deleteAlbumsAsync = deleteAlbumsAsync;\nexports.deleteAssetsAsync = deleteAssetsAsync;\nexports.getAlbumAsync = getAlbumAsync;\nexports.getAlbumsAsync = getAlbumsAsync;\nexports.getAssetInfoAsync = getAssetInfoAsync;\nexports.getAssetsAsync = getAssetsAsync;\nexports.getMomentsAsync = getMomentsAsync;\nexports.getPermissionsAsync = getPermissionsAsync;\nexports.isAvailableAsync = isAvailableAsync;\nexports.migrateAlbumIfNeededAsync = migrateAlbumIfNeededAsync;\nexports.presentPermissionsPickerAsync = presentPermissionsPickerAsync;\nexports.removeAllListeners = removeAllListeners;\nexports.removeAssetsFromAlbumAsync = removeAssetsFromAlbumAsync;\nexports.removeSubscription = removeSubscription;\nexports.requestPermissionsAsync = requestPermissionsAsync;\nexports.saveToLibraryAsync = saveToLibraryAsync;\nexports.usePermissions = void 0;\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _expoModulesCore = require(\"expo-modules-core\");\n\nvar _reactNative = require(\"react-native\");\n\nvar _ExponentMediaLibrary = _interopRequireDefault(require(\"./ExponentMediaLibrary\"));\n\nvar eventEmitter = new _expoModulesCore.EventEmitter(_ExponentMediaLibrary.default);\n\nfunction arrayize(item) {\n  if (Array.isArray(item)) {\n    return item;\n  }\n\n  return item ? [item] : [];\n}\n\nfunction getId(ref) {\n  if (typeof ref === 'string') {\n    return ref;\n  }\n\n  return ref ? ref.id : undefined;\n}\n\nfunction checkAssetIds(assetIds) {\n  if (assetIds.some(function (id) {\n    return !id || typeof id !== 'string';\n  })) {\n    throw new Error('Asset ID must be a string!');\n  }\n}\n\nfunction checkAlbumIds(albumIds) {\n  if (albumIds.some(function (id) {\n    return !id || typeof id !== 'string';\n  })) {\n    throw new Error('Album ID must be a string!');\n  }\n}\n\nfunction checkMediaType(mediaType) {\n  if (Object.values(MediaType).indexOf(mediaType) === -1) {\n    throw new Error(\"Invalid mediaType: \" + mediaType);\n  }\n}\n\nfunction checkSortBy(sortBy) {\n  if (Array.isArray(sortBy)) {\n    checkSortByKey(sortBy[0]);\n\n    if (typeof sortBy[1] !== 'boolean') {\n      throw new Error('Invalid sortBy array argument. Second item must be a boolean!');\n    }\n  } else {\n    checkSortByKey(sortBy);\n  }\n}\n\nfunction checkSortByKey(sortBy) {\n  if (Object.values(SortBy).indexOf(sortBy) === -1) {\n    throw new Error(\"Invalid sortBy key: \" + sortBy);\n  }\n}\n\nfunction dateToNumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\n\nvar MediaType = _ExponentMediaLibrary.default.MediaType;\nexports.MediaType = MediaType;\nvar SortBy = _ExponentMediaLibrary.default.SortBy;\nexports.SortBy = SortBy;\n\nfunction isAvailableAsync() {\n  return _isAvailableAsync.apply(this, arguments);\n}\n\nfunction _isAvailableAsync() {\n  _isAvailableAsync = (0, _asyncToGenerator2.default)(function* () {\n    return !!_ExponentMediaLibrary.default && 'getAssetsAsync' in _ExponentMediaLibrary.default;\n  });\n  return _isAvailableAsync.apply(this, arguments);\n}\n\nfunction requestPermissionsAsync() {\n  return _requestPermissionsAsync.apply(this, arguments);\n}\n\nfunction _requestPermissionsAsync() {\n  _requestPermissionsAsync = (0, _asyncToGenerator2.default)(function* () {\n    var writeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (!_ExponentMediaLibrary.default.requestPermissionsAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'requestPermissionsAsync');\n    }\n\n    return yield _ExponentMediaLibrary.default.requestPermissionsAsync(writeOnly);\n  });\n  return _requestPermissionsAsync.apply(this, arguments);\n}\n\nfunction getPermissionsAsync() {\n  return _getPermissionsAsync.apply(this, arguments);\n}\n\nfunction _getPermissionsAsync() {\n  _getPermissionsAsync = (0, _asyncToGenerator2.default)(function* () {\n    var writeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (!_ExponentMediaLibrary.default.getPermissionsAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'getPermissionsAsync');\n    }\n\n    return yield _ExponentMediaLibrary.default.getPermissionsAsync(writeOnly);\n  });\n  return _getPermissionsAsync.apply(this, arguments);\n}\n\nvar usePermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: function getMethod(options) {\n    return getPermissionsAsync(options == null ? void 0 : options.writeOnly);\n  },\n  requestMethod: function requestMethod(options) {\n    return requestPermissionsAsync(options == null ? void 0 : options.writeOnly);\n  }\n});\nexports.usePermissions = usePermissions;\n\nfunction presentPermissionsPickerAsync() {\n  return _presentPermissionsPickerAsync.apply(this, arguments);\n}\n\nfunction _presentPermissionsPickerAsync() {\n  _presentPermissionsPickerAsync = (0, _asyncToGenerator2.default)(function* () {\n    if (!_ExponentMediaLibrary.default.presentPermissionsPickerAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'presentPermissionsPickerAsync');\n    }\n\n    return yield _ExponentMediaLibrary.default.presentPermissionsPickerAsync();\n  });\n  return _presentPermissionsPickerAsync.apply(this, arguments);\n}\n\nfunction createAssetAsync(_x) {\n  return _createAssetAsync.apply(this, arguments);\n}\n\nfunction _createAssetAsync() {\n  _createAssetAsync = (0, _asyncToGenerator2.default)(function* (localUri) {\n    if (!_ExponentMediaLibrary.default.createAssetAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'createAssetAsync');\n    }\n\n    if (!localUri || typeof localUri !== 'string') {\n      throw new Error('Invalid argument \"localUri\". It must be a string!');\n    }\n\n    var asset = yield _ExponentMediaLibrary.default.createAssetAsync(localUri);\n\n    if (Array.isArray(asset)) {\n      return asset[0];\n    }\n\n    return asset;\n  });\n  return _createAssetAsync.apply(this, arguments);\n}\n\nfunction saveToLibraryAsync(_x2) {\n  return _saveToLibraryAsync.apply(this, arguments);\n}\n\nfunction _saveToLibraryAsync() {\n  _saveToLibraryAsync = (0, _asyncToGenerator2.default)(function* (localUri) {\n    if (!_ExponentMediaLibrary.default.saveToLibraryAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'saveToLibraryAsync');\n    }\n\n    return yield _ExponentMediaLibrary.default.saveToLibraryAsync(localUri);\n  });\n  return _saveToLibraryAsync.apply(this, arguments);\n}\n\nfunction addAssetsToAlbumAsync(_x3, _x4) {\n  return _addAssetsToAlbumAsync.apply(this, arguments);\n}\n\nfunction _addAssetsToAlbumAsync() {\n  _addAssetsToAlbumAsync = (0, _asyncToGenerator2.default)(function* (assets, album) {\n    var copy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (!_ExponentMediaLibrary.default.addAssetsToAlbumAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'addAssetsToAlbumAsync');\n    }\n\n    var assetIds = arrayize(assets).map(getId);\n    var albumId = getId(album);\n    checkAssetIds(assetIds);\n\n    if (!albumId || typeof albumId !== 'string') {\n      throw new Error('Invalid album ID. It must be a string!');\n    }\n\n    if (_reactNative.Platform.OS === 'ios') {\n      return yield _ExponentMediaLibrary.default.addAssetsToAlbumAsync(assetIds, albumId);\n    }\n\n    return yield _ExponentMediaLibrary.default.addAssetsToAlbumAsync(assetIds, albumId, !!copy);\n  });\n  return _addAssetsToAlbumAsync.apply(this, arguments);\n}\n\nfunction removeAssetsFromAlbumAsync(_x5, _x6) {\n  return _removeAssetsFromAlbumAsync.apply(this, arguments);\n}\n\nfunction _removeAssetsFromAlbumAsync() {\n  _removeAssetsFromAlbumAsync = (0, _asyncToGenerator2.default)(function* (assets, album) {\n    if (!_ExponentMediaLibrary.default.removeAssetsFromAlbumAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'removeAssetsFromAlbumAsync');\n    }\n\n    var assetIds = arrayize(assets).map(getId);\n    var albumId = getId(album);\n    checkAssetIds(assetIds);\n    return yield _ExponentMediaLibrary.default.removeAssetsFromAlbumAsync(assetIds, albumId);\n  });\n  return _removeAssetsFromAlbumAsync.apply(this, arguments);\n}\n\nfunction deleteAssetsAsync(_x7) {\n  return _deleteAssetsAsync.apply(this, arguments);\n}\n\nfunction _deleteAssetsAsync() {\n  _deleteAssetsAsync = (0, _asyncToGenerator2.default)(function* (assets) {\n    if (!_ExponentMediaLibrary.default.deleteAssetsAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'deleteAssetsAsync');\n    }\n\n    var assetIds = arrayize(assets).map(getId);\n    checkAssetIds(assetIds);\n    return yield _ExponentMediaLibrary.default.deleteAssetsAsync(assetIds);\n  });\n  return _deleteAssetsAsync.apply(this, arguments);\n}\n\nfunction getAssetInfoAsync(_x8) {\n  return _getAssetInfoAsync.apply(this, arguments);\n}\n\nfunction _getAssetInfoAsync() {\n  _getAssetInfoAsync = (0, _asyncToGenerator2.default)(function* (asset) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      shouldDownloadFromNetwork: true\n    };\n\n    if (!_ExponentMediaLibrary.default.getAssetInfoAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'getAssetInfoAsync');\n    }\n\n    var assetId = getId(asset);\n    checkAssetIds([assetId]);\n    var assetInfo = yield _ExponentMediaLibrary.default.getAssetInfoAsync(assetId, options);\n\n    if (Array.isArray(assetInfo)) {\n      return assetInfo[0];\n    }\n\n    return assetInfo;\n  });\n  return _getAssetInfoAsync.apply(this, arguments);\n}\n\nfunction getAlbumsAsync() {\n  return _getAlbumsAsync.apply(this, arguments);\n}\n\nfunction _getAlbumsAsync() {\n  _getAlbumsAsync = (0, _asyncToGenerator2.default)(function* () {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$includeSmartAlbu = _ref.includeSmartAlbums,\n        includeSmartAlbums = _ref$includeSmartAlbu === void 0 ? false : _ref$includeSmartAlbu;\n\n    if (!_ExponentMediaLibrary.default.getAlbumsAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'getAlbumsAsync');\n    }\n\n    return yield _ExponentMediaLibrary.default.getAlbumsAsync({\n      includeSmartAlbums: includeSmartAlbums\n    });\n  });\n  return _getAlbumsAsync.apply(this, arguments);\n}\n\nfunction getAlbumAsync(_x9) {\n  return _getAlbumAsync.apply(this, arguments);\n}\n\nfunction _getAlbumAsync() {\n  _getAlbumAsync = (0, _asyncToGenerator2.default)(function* (title) {\n    if (!_ExponentMediaLibrary.default.getAlbumAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'getAlbumAsync');\n    }\n\n    if (typeof title !== 'string') {\n      throw new Error('Album title must be a string!');\n    }\n\n    return yield _ExponentMediaLibrary.default.getAlbumAsync(title);\n  });\n  return _getAlbumAsync.apply(this, arguments);\n}\n\nfunction createAlbumAsync(_x10, _x11) {\n  return _createAlbumAsync.apply(this, arguments);\n}\n\nfunction _createAlbumAsync() {\n  _createAlbumAsync = (0, _asyncToGenerator2.default)(function* (albumName, asset) {\n    var copyAsset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (!_ExponentMediaLibrary.default.createAlbumAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'createAlbumAsync');\n    }\n\n    var assetId = getId(asset);\n\n    if (_reactNative.Platform.OS === 'android' && (typeof assetId !== 'string' || assetId.length === 0)) {\n      throw new Error('MediaLibrary.createAlbumAsync must be called with an asset on Android.');\n    }\n\n    if (!albumName || typeof albumName !== 'string') {\n      throw new Error('Invalid argument \"albumName\". It must be a string!');\n    }\n\n    if (assetId != null && typeof assetId !== 'string') {\n      throw new Error('Asset ID must be a string!');\n    }\n\n    if (_reactNative.Platform.OS === 'ios') {\n      return yield _ExponentMediaLibrary.default.createAlbumAsync(albumName, assetId);\n    }\n\n    return yield _ExponentMediaLibrary.default.createAlbumAsync(albumName, assetId, !!copyAsset);\n  });\n  return _createAlbumAsync.apply(this, arguments);\n}\n\nfunction deleteAlbumsAsync(_x12) {\n  return _deleteAlbumsAsync.apply(this, arguments);\n}\n\nfunction _deleteAlbumsAsync() {\n  _deleteAlbumsAsync = (0, _asyncToGenerator2.default)(function* (albums) {\n    var assetRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!_ExponentMediaLibrary.default.deleteAlbumsAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'deleteAlbumsAsync');\n    }\n\n    var albumIds = arrayize(albums).map(getId);\n    checkAlbumIds(albumIds);\n\n    if (_reactNative.Platform.OS === 'android') {\n      return yield _ExponentMediaLibrary.default.deleteAlbumsAsync(albumIds);\n    }\n\n    return yield _ExponentMediaLibrary.default.deleteAlbumsAsync(albumIds, !!assetRemove);\n  });\n  return _deleteAlbumsAsync.apply(this, arguments);\n}\n\nfunction getAssetsAsync() {\n  return _getAssetsAsync.apply(this, arguments);\n}\n\nfunction _getAssetsAsync() {\n  _getAssetsAsync = (0, _asyncToGenerator2.default)(function* () {\n    var assetsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!_ExponentMediaLibrary.default.getAssetsAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'getAssetsAsync');\n    }\n\n    var first = assetsOptions.first,\n        after = assetsOptions.after,\n        album = assetsOptions.album,\n        sortBy = assetsOptions.sortBy,\n        mediaType = assetsOptions.mediaType,\n        createdAfter = assetsOptions.createdAfter,\n        createdBefore = assetsOptions.createdBefore;\n    var options = {\n      first: first == null ? 20 : first,\n      after: getId(after),\n      album: getId(album),\n      sortBy: arrayize(sortBy),\n      mediaType: arrayize(mediaType || [MediaType.photo]),\n      createdAfter: dateToNumber(createdAfter),\n      createdBefore: dateToNumber(createdBefore)\n    };\n\n    if (first != null && typeof options.first !== 'number') {\n      throw new Error('Option \"first\" must be a number!');\n    }\n\n    if (after != null && typeof options.after !== 'string') {\n      throw new Error('Option \"after\" must be a string!');\n    }\n\n    if (album != null && typeof options.album !== 'string') {\n      throw new Error('Option \"album\" must be a string!');\n    }\n\n    if (after != null && _reactNative.Platform.OS === 'android' && isNaN(parseInt(getId(after), 10))) {\n      throw new Error('Option \"after\" must be a valid ID!');\n    }\n\n    if (first != null && first < 0) {\n      throw new Error('Option \"first\" must be a positive integer!');\n    }\n\n    options.sortBy.forEach(checkSortBy);\n    options.mediaType.forEach(checkMediaType);\n    return yield _ExponentMediaLibrary.default.getAssetsAsync(options);\n  });\n  return _getAssetsAsync.apply(this, arguments);\n}\n\nfunction addListener(listener) {\n  return eventEmitter.addListener(_ExponentMediaLibrary.default.CHANGE_LISTENER_NAME, listener);\n}\n\nfunction removeSubscription(subscription) {\n  subscription.remove();\n}\n\nfunction removeAllListeners() {\n  eventEmitter.removeAllListeners(_ExponentMediaLibrary.default.CHANGE_LISTENER_NAME);\n}\n\nfunction getMomentsAsync() {\n  return _getMomentsAsync.apply(this, arguments);\n}\n\nfunction _getMomentsAsync() {\n  _getMomentsAsync = (0, _asyncToGenerator2.default)(function* () {\n    if (!_ExponentMediaLibrary.default.getMomentsAsync) {\n      throw new _expoModulesCore.UnavailabilityError('MediaLibrary', 'getMomentsAsync');\n    }\n\n    return yield _ExponentMediaLibrary.default.getMomentsAsync();\n  });\n  return _getMomentsAsync.apply(this, arguments);\n}\n\nfunction migrateAlbumIfNeededAsync(_x13) {\n  return _migrateAlbumIfNeededAsync.apply(this, arguments);\n}\n\nfunction _migrateAlbumIfNeededAsync() {\n  _migrateAlbumIfNeededAsync = (0, _asyncToGenerator2.default)(function* (album) {\n    if (!_ExponentMediaLibrary.default.migrateAlbumIfNeededAsync) {\n      return;\n    }\n\n    return yield _ExponentMediaLibrary.default.migrateAlbumIfNeededAsync(getId(album));\n  });\n  return _migrateAlbumIfNeededAsync.apply(this, arguments);\n}\n\nfunction albumNeedsMigrationAsync(_x14) {\n  return _albumNeedsMigrationAsync.apply(this, arguments);\n}\n\nfunction _albumNeedsMigrationAsync() {\n  _albumNeedsMigrationAsync = (0, _asyncToGenerator2.default)(function* (album) {\n    if (!_ExponentMediaLibrary.default.albumNeedsMigrationAsync) {\n      return false;\n    }\n\n    return yield _ExponentMediaLibrary.default.albumNeedsMigrationAsync(getId(album));\n  });\n  return _albumNeedsMigrationAsync.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["eventEmitter","EventEmitter","MediaLibrary","arrayize","item","Array","isArray","getId","ref","id","undefined","checkAssetIds","assetIds","some","Error","checkAlbumIds","albumIds","checkMediaType","mediaType","Object","values","MediaType","indexOf","checkSortBy","sortBy","checkSortByKey","SortBy","dateToNumber","value","Date","getTime","isAvailableAsync","requestPermissionsAsync","writeOnly","UnavailabilityError","getPermissionsAsync","usePermissions","getMethod","options","requestMethod","presentPermissionsPickerAsync","createAssetAsync","localUri","asset","saveToLibraryAsync","addAssetsToAlbumAsync","assets","album","copy","map","albumId","Platform","OS","removeAssetsFromAlbumAsync","deleteAssetsAsync","getAssetInfoAsync","shouldDownloadFromNetwork","assetId","assetInfo","getAlbumsAsync","includeSmartAlbums","getAlbumAsync","title","createAlbumAsync","albumName","copyAsset","length","deleteAlbumsAsync","albums","assetRemove","getAssetsAsync","assetsOptions","first","after","createdAfter","createdBefore","photo","isNaN","parseInt","forEach","addListener","listener","CHANGE_LISTENER_NAME","removeSubscription","subscription","remove","removeAllListeners","getMomentsAsync","migrateAlbumIfNeededAsync","albumNeedsMigrationAsync"],"sources":["/Users/kevin/Desktop/group-1010001/front-mobile-gpe/node_modules/expo-media-library/src/MediaLibrary.ts"],"sourcesContent":["import {\n  PermissionResponse as EXPermissionResponse,\n  PermissionStatus,\n  PermissionExpiration,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  UnavailabilityError,\n} from 'expo-modules-core';\nimport { Platform } from 'react-native';\n\nimport MediaLibrary from './ExponentMediaLibrary';\n\nconst eventEmitter = new EventEmitter(MediaLibrary);\n\n// @needsAudit\nexport type PermissionResponse = EXPermissionResponse & {\n  /**\n   * Indicates if your app has access to the whole or only part of the photo library. Possible values are:\n   * - `'all'` if the user granted your app access to the whole photo library\n   * - `'limited'` if the user granted your app access only to selected photos (only available on iOS 14.0+)\n   * - `'none'` if user denied or hasn't yet granted the permission\n   */\n  accessPrivileges?: 'all' | 'limited' | 'none';\n};\n\nexport type MediaTypeValue = 'audio' | 'photo' | 'video' | 'unknown';\nexport type SortByKey =\n  | 'default'\n  | 'mediaType'\n  | 'width'\n  | 'height'\n  | 'creationTime'\n  | 'modificationTime'\n  | 'duration';\nexport type SortByValue = [SortByKey, boolean] | SortByKey;\n\nexport type MediaTypeObject = {\n  audio: 'audio';\n  photo: 'photo';\n  video: 'video';\n  unknown: 'unknown';\n};\n\nexport type SortByObject = {\n  default: 'default';\n  mediaType: 'mediaType';\n  width: 'width';\n  height: 'height';\n  creationTime: 'creationTime';\n  modificationTime: 'modificationTime';\n  duration: 'duration';\n};\n\n// @needsAudit\nexport type Asset = {\n  /**\n   * Internal ID that represents an asset.\n   */\n  id: string;\n  /**\n   * Filename of the asset.\n   */\n  filename: string;\n  /**\n   * URI that points to the asset. `assets://*` (iOS), `file://*` (Android)\n   */\n  uri: string;\n  /**\n   * Media type.\n   */\n  mediaType: MediaTypeValue;\n  /**\n   * An array of media subtypes.\n   * @platform ios\n   */\n  mediaSubtypes?: MediaSubtype[];\n  /**\n   * Width of the image or video.\n   */\n  width: number;\n  /**\n   * Height of the image or video.\n   */\n  height: number;\n  /**\n   * File creation timestamp.\n   */\n  creationTime: number;\n  /**\n   * Last modification timestamp.\n   */\n  modificationTime: number;\n  /**\n   * Duration of the video or audio asset in seconds.\n   */\n  duration: number;\n  /**\n   * Album ID that the asset belongs to.\n   * @platform android\n   */\n  albumId?: string;\n};\n\n// @needsAudit\nexport type AssetInfo = Asset & {\n  /**\n   * Local URI for the asset.\n   */\n  localUri?: string;\n  /**\n   * GPS location if available.\n   */\n  location?: Location;\n  /**\n   * EXIF metadata associated with the image.\n   */\n  exif?: object;\n  /**\n   * Whether the asset is marked as favorite.\n   * @platform ios\n   */\n  isFavorite?: boolean;\n  /**\n   * This field is available only if flag `shouldDownloadFromNetwork` is set to `false`.\n   * Whether the asset is stored on the network (iCloud on iOS).\n   * @platform ios\n   */\n  isNetworkAsset?: boolean; //iOS only\n  /**\n   * Display orientation of the image. Orientation is available only for assets whose\n   * `mediaType` is `MediaType.photo`. Value will range from 1 to 8, see [EXIF orientation specification](http://sylvana.net/jpegcrop/exif_orientation.html)\n   * for more details.\n   * @platform ios\n   */\n  orientation?: number;\n};\n\n// @docsMissing\nexport type MediaSubtype =\n  | 'depthEffect'\n  | 'hdr'\n  | 'highFrameRate'\n  | 'livePhoto'\n  | 'panorama'\n  | 'screenshot'\n  | 'stream'\n  | 'timelapse';\n\n// @needsAudit\nexport type MediaLibraryAssetInfoQueryOptions = {\n  /**\n   * Whether allow the asset to be downloaded from network. Only available in iOS with iCloud assets.\n   * @default true\n   */\n  shouldDownloadFromNetwork?: boolean;\n};\n\n// @needsAudit\nexport type MediaLibraryAssetsChangeEvent = {\n  /**\n   * Whether the media library's changes could be described as \"incremental changes\".\n   * `true` indicates the changes are described by the `insertedAssets`, `deletedAssets` and\n   * `updatedAssets` values. `false` indicates that the scope of changes is too large and you\n   * should perform a full assets reload (eg. a user has changed access to individual assets in the\n   * media library).\n   */\n  hasIncrementalChanges: boolean;\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been inserted to the library.\n   */\n  insertedAssets?: Asset[];\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been deleted from the library.\n   */\n  deletedAssets?: Asset[];\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been updated or completed downloading from network\n   * storage (iCloud on iOS).\n   */\n  updatedAssets?: Asset[];\n};\n\n// @docsMissing\nexport type Location = {\n  latitude: number;\n  longitude: number;\n};\n\n// @needsAudit\nexport type Album = {\n  /**\n   * Album ID.\n   */\n  id: string;\n  /**\n   * Album title.\n   */\n  title: string;\n  /**\n   * Estimated number of assets in the album.\n   */\n  assetCount: number;\n  /**\n   * The type of the assets album.\n   * @platform ios\n   */\n  type?: AlbumType;\n  /**\n   * Apply only to albums whose type is `'moment'`. Earliest creation timestamp of all\n   * assets in the moment.\n   * @platform ios\n   */\n  startTime: number;\n  /**\n   * Apply only to albums whose type is `'moment'`. Latest creation timestamp of all\n   * assets in the moment.\n   * @platform ios\n   */\n  endTime: number;\n  /**\n   * Apply only to albums whose type is `'moment'`. Approximated location of all\n   * assets in the moment.\n   * @platform ios\n   */\n  approximateLocation?: Location;\n  /**\n   * Apply only to albums whose type is `'moment'`. Names of locations grouped\n   * in the moment.\n   * @platform ios\n   */\n  locationNames?: string[];\n};\n\n// @docsMissing\nexport type AlbumType = 'album' | 'moment' | 'smartAlbum';\n\n// @docsMissing\nexport type AlbumsOptions = {\n  includeSmartAlbums?: boolean;\n};\n\n// @needsAudit\nexport type AssetsOptions = {\n  /**\n   * The maximum number of items on a single page.\n   * @default 20\n   */\n  first?: number;\n  /**\n   * Asset ID of the last item returned on the previous page.\n   */\n  after?: AssetRef;\n  /**\n   * [Album](#album) or its ID to get assets from specific album.\n   */\n  album?: AlbumRef;\n  /**\n   * An array of [`SortByValue`](#sortbyvalue)s or a single `SortByValue` value. By default, all\n   * keys are sorted in descending order, however you can also pass a pair `[key, ascending]` where\n   * the second item is a `boolean` value that means whether to use ascending order. Note that if\n   * the `SortBy.default` key is used, then `ascending` argument will not matter. Earlier items have\n   * higher priority when sorting out the results.\n   * If empty, this method will use the default sorting that is provided by the platform.\n   */\n  sortBy?: SortByValue[] | SortByValue;\n  /**\n   * An array of [MediaTypeValue](#expomedialibrarymediatypevalue)s or a single `MediaTypeValue`.\n   * @default MediaType.photo\n   */\n  mediaType?: MediaTypeValue[] | MediaTypeValue;\n  /**\n   * `Date` object or Unix timestamp in milliseconds limiting returned assets only to those that\n   * were created after this date.\n   */\n  createdAfter?: Date | number;\n  /**\n   * Similarly as `createdAfter`, but limits assets only to those that were created before specified\n   * date.\n   */\n  createdBefore?: Date | number;\n};\n\n// @needsAudit\nexport type PagedInfo<T> = {\n  /**\n   * A page of [`Asset`](#asset)s fetched by the query.\n   */\n  assets: T[];\n  /**\n   * ID of the last fetched asset. It should be passed as `after` option in order to get the\n   * next page.\n   */\n  endCursor: string;\n  /**\n   * Whether there are more assets to fetch.\n   */\n  hasNextPage: boolean;\n  /**\n   * Estimated total number of assets that match the query.\n   */\n  totalCount: number;\n};\n\n// @docsMissing\nexport type AssetRef = Asset | string;\n\n// @docsMissing\nexport type AlbumRef = Album | string;\n\nexport {\n  PermissionStatus,\n  PermissionExpiration,\n  EXPermissionResponse,\n  PermissionHookOptions,\n  Subscription,\n};\n\nfunction arrayize(item: any): any[] {\n  if (Array.isArray(item)) {\n    return item;\n  }\n  return item ? [item] : [];\n}\n\nfunction getId(ref: any): string | undefined {\n  if (typeof ref === 'string') {\n    return ref;\n  }\n  return ref ? ref.id : undefined;\n}\n\nfunction checkAssetIds(assetIds: any): void {\n  if (assetIds.some((id) => !id || typeof id !== 'string')) {\n    throw new Error('Asset ID must be a string!');\n  }\n}\n\nfunction checkAlbumIds(albumIds: any): void {\n  if (albumIds.some((id) => !id || typeof id !== 'string')) {\n    throw new Error('Album ID must be a string!');\n  }\n}\n\nfunction checkMediaType(mediaType: any): void {\n  if (Object.values(MediaType).indexOf(mediaType) === -1) {\n    throw new Error(`Invalid mediaType: ${mediaType}`);\n  }\n}\n\nfunction checkSortBy(sortBy: any): void {\n  if (Array.isArray(sortBy)) {\n    checkSortByKey(sortBy[0]);\n\n    if (typeof sortBy[1] !== 'boolean') {\n      throw new Error('Invalid sortBy array argument. Second item must be a boolean!');\n    }\n  } else {\n    checkSortByKey(sortBy);\n  }\n}\n\nfunction checkSortByKey(sortBy: any): void {\n  if (Object.values(SortBy).indexOf(sortBy) === -1) {\n    throw new Error(`Invalid sortBy key: ${sortBy}`);\n  }\n}\n\nfunction dateToNumber(value?: Date | number): number | undefined {\n  return value instanceof Date ? value.getTime() : value;\n}\n\n// @needsAudit\n/**\n * Possible media types.\n */\nexport const MediaType: MediaTypeObject = MediaLibrary.MediaType;\n\n// @needsAudit\n/**\n * Supported keys that can be used to sort `getAssetsAsync` results.\n */\nexport const SortBy: SortByObject = MediaLibrary.SortBy;\n\n// @needsAudit\n/**\n * Returns whether the Media Library API is enabled on the current device.\n * @return A promise which fulfils with a `boolean`, indicating whether the Media Library API is\n * available on the current device.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!MediaLibrary && 'getAssetsAsync' in MediaLibrary;\n}\n\n// @needsAudit @docsMissing\n/**\n * Asks the user to grant permissions for accessing media in user's media library.\n * @param writeOnly\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function requestPermissionsAsync(\n  writeOnly: boolean = false\n): Promise<PermissionResponse> {\n  if (!MediaLibrary.requestPermissionsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'requestPermissionsAsync');\n  }\n  return await MediaLibrary.requestPermissionsAsync(writeOnly);\n}\n\n// @needsAudit @docsMissing\n/**\n * Checks user's permissions for accessing media library.\n * @param writeOnly\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function getPermissionsAsync(writeOnly: boolean = false): Promise<PermissionResponse> {\n  if (!MediaLibrary.getPermissionsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getPermissionsAsync');\n  }\n  return await MediaLibrary.getPermissionsAsync(writeOnly);\n}\n\n// @needsAudit\n/**\n * Check or request permissions to access the media library.\n * This uses both `requestPermissionsAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [permissionResponse, requestPermission] = MediaLibrary.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook<PermissionResponse, { writeOnly?: boolean }>({\n  // TODO(cedric): permission requesters should have an options param or a different requester\n  getMethod: (options) => getPermissionsAsync(options?.writeOnly),\n  requestMethod: (options) => requestPermissionsAsync(options?.writeOnly),\n});\n\n// @needsAudit\n/**\n * __Available only on iOS >= 14.__ Allows the user to update the assets that your app has access to.\n * The system modal is only displayed if the user originally allowed only `limited` access to their\n * media library, otherwise this method is a no-op.\n * @return A promise that either rejects if the method is unavailable (meaning the device is not\n * running iOS >= 14), or resolves to `void`.\n * > __Note:__ This method doesn't inform you if the user changes which assets your app has access to.\n * For that information, you need to subscribe for updates to the user's media library using [addListener(listener)](#medialibraryaddlistenerlistener).\n * If `hasIncrementalChanges` is `false`, the user changed their permissions.\n */\nexport async function presentPermissionsPickerAsync(): Promise<void> {\n  if (!MediaLibrary.presentPermissionsPickerAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'presentPermissionsPickerAsync');\n  }\n  return await MediaLibrary.presentPermissionsPickerAsync();\n}\n\n// @needsAudit\n/**\n * Creates an asset from existing file. The most common use case is to save a picture taken by [Camera](./camera).\n * This method requires `CAMERA_ROLL` permission.\n *\n * @example\n * ```js\n * const { uri } = await Camera.takePictureAsync();\n * const asset = await MediaLibrary.createAssetAsync(uri);\n * ```\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`\n * @return A promise which fulfils with an object representing an [`Asset`](#asset).\n */\nexport async function createAssetAsync(localUri: string): Promise<Asset> {\n  if (!MediaLibrary.createAssetAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'createAssetAsync');\n  }\n\n  if (!localUri || typeof localUri !== 'string') {\n    throw new Error('Invalid argument \"localUri\". It must be a string!');\n  }\n  const asset = await MediaLibrary.createAssetAsync(localUri);\n\n  if (Array.isArray(asset)) {\n    // Android returns an array with asset, we need to pick the first item\n    return asset[0];\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * Saves the file at given `localUri` to the user's media library. Unlike [`createAssetAsync()`](#medialibrarycreateassetasynclocaluri),\n * This method doesn't return created asset.\n * On __iOS 11+__, it's possible to use this method without asking for `CAMERA_ROLL` permission,\n * however then yours `Info.plist` should have `NSPhotoLibraryAddUsageDescription` key.\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`.\n */\nexport async function saveToLibraryAsync(localUri: string): Promise<void> {\n  if (!MediaLibrary.saveToLibraryAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'saveToLibraryAsync');\n  }\n  return await MediaLibrary.saveToLibraryAsync(localUri);\n}\n\n// @needsAudit\n/**\n * Adds array of assets to the album.\n *\n * On Android, by default it copies assets from the current album to provided one, however it's also\n * possible to move them by passing `false` as `copyAssets` argument.In case they're copied you\n * should keep in mind that `getAssetsAsync` will return duplicated assets.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @param copy __Android only.__ Whether to copy assets to the new album instead of move them.\n * Defaults to `true`.\n * @return Returns promise which fulfils with `true` if the assets were successfully added to\n * the album.\n */\nexport async function addAssetsToAlbumAsync(\n  assets: AssetRef[] | AssetRef,\n  album: AlbumRef,\n  copy: boolean = true\n): Promise<boolean> {\n  if (!MediaLibrary.addAssetsToAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'addAssetsToAlbumAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n  const albumId = getId(album);\n\n  checkAssetIds(assetIds);\n\n  if (!albumId || typeof albumId !== 'string') {\n    throw new Error('Invalid album ID. It must be a string!');\n  }\n\n  if (Platform.OS === 'ios') {\n    return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId);\n  }\n  return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId, !!copy);\n}\n\n// @needsAudit\n/**\n * Removes given assets from album.\n *\n * On Android, album will be automatically deleted if there are no more assets inside.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @return Returns promise which fulfils with `true` if the assets were successfully removed from\n * the album.\n */\nexport async function removeAssetsFromAlbumAsync(\n  assets: AssetRef[] | AssetRef,\n  album: AlbumRef\n): Promise<boolean> {\n  if (!MediaLibrary.removeAssetsFromAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'removeAssetsFromAlbumAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n  const albumId = getId(album);\n\n  checkAssetIds(assetIds);\n  return await MediaLibrary.removeAssetsFromAlbumAsync(assetIds, albumId);\n}\n\n// @needsAudit\n/**\n * Deletes assets from the library. On iOS it deletes assets from all albums they belong to, while\n * on Android it keeps all copies of them (album is strictly connected to the asset). Also, there is\n * additional dialog on iOS that requires user to confirm this action.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @return Returns promise which fulfils with `true` if the assets were successfully deleted.\n */\nexport async function deleteAssetsAsync(assets: AssetRef[] | AssetRef): Promise<boolean> {\n  if (!MediaLibrary.deleteAssetsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'deleteAssetsAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n\n  checkAssetIds(assetIds);\n  return await MediaLibrary.deleteAssetsAsync(assetIds);\n}\n\n// @needsAudit\n/**\n * Provides more information about an asset, including GPS location, local URI and EXIF metadata.\n * @param asset An [Asset](#asset) or its ID.\n * @param options\n * @return An [AssetInfo](#assetinfo) object, which is an `Asset` extended by an additional fields.\n */\nexport async function getAssetInfoAsync(\n  asset: AssetRef,\n  options: MediaLibraryAssetInfoQueryOptions = { shouldDownloadFromNetwork: true }\n): Promise<AssetInfo> {\n  if (!MediaLibrary.getAssetInfoAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAssetInfoAsync');\n  }\n\n  const assetId = getId(asset);\n\n  checkAssetIds([assetId]);\n\n  const assetInfo = await MediaLibrary.getAssetInfoAsync(assetId, options);\n\n  if (Array.isArray(assetInfo)) {\n    // Android returns an array with asset info, we need to pick the first item\n    return assetInfo[0];\n  }\n  return assetInfo;\n}\n\n// @needsAudit\n/**\n * Queries for user-created albums in media gallery.\n * @return A promise which fulfils with an array of [`Album`](#asset)s. Depending on Android version,\n * root directory of your storage may be listed as album titled `\"0\"` or unlisted at all.\n */\nexport async function getAlbumsAsync({ includeSmartAlbums = false }: AlbumsOptions = {}): Promise<\n  Album[]\n> {\n  if (!MediaLibrary.getAlbumsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAlbumsAsync');\n  }\n  return await MediaLibrary.getAlbumsAsync({ includeSmartAlbums });\n}\n\n// @needsAudit\n/**\n * Queries for an album with a specific name.\n * @param title Name of the album to look for.\n * @return An object representing an [`Album`](#album), if album with given name exists, otherwise\n * returns `null`.\n */\nexport async function getAlbumAsync(title: string): Promise<Album> {\n  if (!MediaLibrary.getAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAlbumAsync');\n  }\n  if (typeof title !== 'string') {\n    throw new Error('Album title must be a string!');\n  }\n  return await MediaLibrary.getAlbumAsync(title);\n}\n\n// @needsAudit\n/**\n * Creates an album with given name and initial asset. The asset parameter is required on Android,\n * since it's not possible to create empty album on this platform. On Android, by default it copies\n * given asset from the current album to the new one, however it's also possible to move it by\n * passing `false` as `copyAsset` argument.\n * In case it's copied you should keep in mind that `getAssetsAsync` will return duplicated asset.\n * @param albumName Name of the album to create.\n * @param asset An [Asset](#asset) or its ID (required on Android).\n * @param copyAsset __Android Only.__ Whether to copy asset to the new album instead of move it.\n * Defaults to `true`.\n * @return Newly created [`Album`](#album).\n */\nexport async function createAlbumAsync(\n  albumName: string,\n  asset?: AssetRef,\n  copyAsset: boolean = true\n): Promise<Album> {\n  if (!MediaLibrary.createAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'createAlbumAsync');\n  }\n\n  const assetId = getId(asset);\n\n  if (Platform.OS === 'android' && (typeof assetId !== 'string' || assetId.length === 0)) {\n    // it's not possible to create empty album on Android, so initial asset must be provided\n    throw new Error('MediaLibrary.createAlbumAsync must be called with an asset on Android.');\n  }\n  if (!albumName || typeof albumName !== 'string') {\n    throw new Error('Invalid argument \"albumName\". It must be a string!');\n  }\n  if (assetId != null && typeof assetId !== 'string') {\n    throw new Error('Asset ID must be a string!');\n  }\n\n  if (Platform.OS === 'ios') {\n    return await MediaLibrary.createAlbumAsync(albumName, assetId);\n  }\n  return await MediaLibrary.createAlbumAsync(albumName, assetId, !!copyAsset);\n}\n\n// @needsAudit\n/**\n * Deletes given albums from the library. On Android by default it deletes assets belonging to given\n * albums from the library. On iOS it doesn't delete these assets, however it's possible to do by\n * passing `true` as `deleteAssets`.\n * @param albums An array of [`Album`](#asset)s or their IDs.\n * @param assetRemove __iOS Only.__ Whether to also delete assets belonging to given albums.\n * Defaults to `false`.\n * @return Returns a promise which fulfils with `true` if the albums were successfully deleted from\n * the library.\n */\nexport async function deleteAlbumsAsync(\n  albums: AlbumRef[] | AlbumRef,\n  assetRemove: boolean = false\n): Promise<boolean> {\n  if (!MediaLibrary.deleteAlbumsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'deleteAlbumsAsync');\n  }\n\n  const albumIds = arrayize(albums).map(getId);\n\n  checkAlbumIds(albumIds);\n  if (Platform.OS === 'android') {\n    return await MediaLibrary.deleteAlbumsAsync(albumIds);\n  }\n  return await MediaLibrary.deleteAlbumsAsync(albumIds, !!assetRemove);\n}\n\n// @needsAudit\n/**\n * Fetches a page of assets matching the provided criteria.\n * @param assetsOptions\n * @return A promise that fulfils with to [`PagedInfo`](#pagedinfo) object with array of [`Asset`](#asset)s.\n */\nexport async function getAssetsAsync(assetsOptions: AssetsOptions = {}): Promise<PagedInfo<Asset>> {\n  if (!MediaLibrary.getAssetsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAssetsAsync');\n  }\n\n  const { first, after, album, sortBy, mediaType, createdAfter, createdBefore } = assetsOptions;\n\n  const options = {\n    first: first == null ? 20 : first,\n    after: getId(after),\n    album: getId(album),\n    sortBy: arrayize(sortBy),\n    mediaType: arrayize(mediaType || [MediaType.photo]),\n    createdAfter: dateToNumber(createdAfter),\n    createdBefore: dateToNumber(createdBefore),\n  };\n\n  if (first != null && typeof options.first !== 'number') {\n    throw new Error('Option \"first\" must be a number!');\n  }\n  if (after != null && typeof options.after !== 'string') {\n    throw new Error('Option \"after\" must be a string!');\n  }\n  if (album != null && typeof options.album !== 'string') {\n    throw new Error('Option \"album\" must be a string!');\n  }\n\n  if (after != null && Platform.OS === 'android' && isNaN(parseInt(getId(after) as string, 10))) {\n    throw new Error('Option \"after\" must be a valid ID!');\n  }\n\n  if (first != null && first < 0) {\n    throw new Error('Option \"first\" must be a positive integer!');\n  }\n\n  options.sortBy.forEach(checkSortBy);\n  options.mediaType.forEach(checkMediaType);\n\n  return await MediaLibrary.getAssetsAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribes for updates in user's media library.\n * @param listener A callback that is fired when any assets have been inserted or deleted from the\n * library, or when the user changes which assets they're allowing access to. On Android it's\n * invoked with an empty object. On iOS it's invoked with [`MediaLibraryAssetsChangeEvent`](#medialibraryassetschangeevent)\n * object.\n * @return An [`Subscription`](#subscription) object that you can call `remove()` on when you would\n * like to unsubscribe the listener.\n */\nexport function addListener(\n  listener: (event: MediaLibraryAssetsChangeEvent) => void\n): Subscription {\n  return eventEmitter.addListener(MediaLibrary.CHANGE_LISTENER_NAME, listener);\n}\n\n// @docsMissing\nexport function removeSubscription(subscription: Subscription): void {\n  subscription.remove();\n}\n\n// @needsAudit\n/**\n * Removes all listeners.\n */\nexport function removeAllListeners(): void {\n  eventEmitter.removeAllListeners(MediaLibrary.CHANGE_LISTENER_NAME);\n}\n\n// @needsAudit\n/**\n * Fetches a list of moments, which is a group of assets taken around the same place\n * and time.\n * @return An array of [albums](#album) whose type is `moment`.\n * @platform ios\n */\nexport async function getMomentsAsync() {\n  if (!MediaLibrary.getMomentsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getMomentsAsync');\n  }\n\n  return await MediaLibrary.getMomentsAsync();\n}\n\n// @needsAudit\n/**\n * Moves album content to the special media directories on **Android R** or **above** if needed.\n * Those new locations are in line with the Android `scoped storage` - so your application won't\n * lose write permission to those directories in the future.\n *\n * This method does nothing if:\n * - app is running on **iOS**, **web** or **Android below R**\n * - app has **write permission** to the album folder\n *\n * The migration is possible when the album contains only compatible files types.\n * For instance, movies and pictures are compatible with each other, but music and pictures are not.\n * If automatic migration isn't possible, the function will be rejected.\n * In that case, you can use methods from the `expo-file-system` to migrate all your files manually.\n *\n * # Why do you need to migrate files?\n * __Android R__ introduced a lot of changes in the storage system. Now applications can't save\n * anything to the root directory. The only available locations are from the `MediaStore` API.\n * Unfortunately, the media library stored albums in folders for which, because of those changes,\n * the application doesn't have permissions anymore. However, it doesn't mean you need to migrate\n * all your albums. If your application doesn't add assets to albums, you don't have to migrate.\n * Everything will work as it used to. You can read more about scoped storage in [the Android documentation](https://developer.android.com/about/versions/11/privacy/storage).\n *\n * @param album An [Album](#album) or its ID.\n * @return A promise which fulfils to `void`.\n */\nexport async function migrateAlbumIfNeededAsync(album: AlbumRef): Promise<void> {\n  if (!MediaLibrary.migrateAlbumIfNeededAsync) {\n    return;\n  }\n\n  return await MediaLibrary.migrateAlbumIfNeededAsync(getId(album));\n}\n\n// @needsAudit\n/**\n * Checks if the album should be migrated to a different location. In other words, it checks if the\n * application has the write permission to the album folder. If not, it returns `true`, otherwise `false`.\n * > Note: For **Android below R**, **web** or **iOS**, this function always returns `false`.\n * @param album An [Album](#album) or its ID.\n * @return Returns a promise which fulfils with `true` if the album should be migrated.\n */\nexport async function albumNeedsMigrationAsync(album: AlbumRef): Promise<boolean> {\n  if (!MediaLibrary.albumNeedsMigrationAsync) {\n    return false;\n  }\n\n  return await MediaLibrary.albumNeedsMigrationAsync(getId(album));\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}